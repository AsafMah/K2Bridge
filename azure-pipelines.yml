# CI/CD Azure DevOps deployment pipeline.
# The following variables can be optionally set for each pipeline run:
# - RUN_FLAG_TERRAFORM: Set to 1 to have `terraform apply`. By default
#   `terraform apply` only runs on the master branch.
# - RUN_FLAG_PROMOTE: Set to 1 to promote the Docker image to `latest` tag if
#   tests are successful. By default this is only done on the master branch.
# - RUN_SET_NAMESPACE: Set to a string to deploy to the given AKS namespace,
#   and not delete the namespace after the build. By default the build deploys to
#   the `master` AKS namespace if run on the master branch, and otherwise to a
#   temporary AKS namespace that is deleted at the end of the build.
# - RUN_CREATE_DEMO_KUSTO: Set to 1 to cause the ADX db creation. this is for
#   just for the demo ADX db and should be set only once after a deletion of
#   that DB (which shouldn't normally happen)
stages:

- stage: x

- stage: security_analysis
  displayName: Security Analysis
  dependsOn: []
  jobs:

  - job: run_analysis
    displayName: Run Analysis

    pool:
      # CredScan only runs on Windows
      vmImage: 'windows-latest'

    steps:
    - task: CredScan@2
      displayName: 'Find credentials in source code'
      inputs:
        toolMajorVersion: 'V2'

    - task: SdtReport@1
      displayName: 'Security analysis report'
      inputs:
        AllTools: false
        APIScan: false
        BinSkim: false
        CodesignValidation: false
        CredScan: true
        FortifySCA: false
        FxCop: false
        ModernCop: false
        MSRD: false
        PoliCheck: false
        RoslynAnalyzers: false
        SDLNativeRules: false
        Semmle: false
        TSLint: false
        ToolLogsNotFoundAction: 'Standard'

    - task: PublishSecurityAnalysisLogs@2
      displayName: 'Publish security analysis logs'
      inputs:
        ArtifactName: 'CodeAnalysisLogs'
        ArtifactType: 'Container'
        AllTools: false
        AntiMalware: false
        APIScan: false
        BinSkim: false
        CodesignValidation: false
        CredScan: true
        FortifySCA: false
        FxCop: false
        ModernCop: false
        MSRD: false
        PoliCheck: false
        RoslynAnalyzers: false
        SDLNativeRules: false
        Semmle: false
        TSLint: false
        WebScout: false
        ToolLogsNotFoundAction: 'Standard'

    - task: PostAnalysis@1
      displayName: 'Post security analysis'
      inputs:
        AllTools: false
        APIScan: false
        BinSkim: false
        CodesignValidation: false
        CredScan: true
        FortifySCA: false
        FxCop: false
        ModernCop: false
        PoliCheck: false
        RoslynAnalyzers: false
        SDLNativeRules: false
        Semmle: false
        TSLint: false
        VstsConsole: false
        ToolLogsNotFoundAction: 'Standard'

    - task: ComponentGovernanceComponentDetection@0
      inputs:
        scanType: 'Register'
        verbosity: 'Verbose'
        alertWarningLevel: 'Medium'
        failOnAlert: true

- stage: build
  displayName: Build
  dependsOn: []
  jobs:

  - job: build_and_unittest
    displayName: Build with UnitTests
    steps:

    - bash: |
        # Only build first stage of Dockerfile (build and unit test)
        docker build --target build --build-arg VersionPrefix="$(SEMANTIC_VERSION)" -t k2bridge-build .
        # Temporarily create container in order to extract test results file
        id=$(docker create k2bridge-build)
        docker cp $id:/app/TestResult.xml .
        docker cp $id:/app/K2Bridge.Tests.UnitTests/coverage.cobertura.xml .
        docker rm $id
      displayName: Docker build & test

    - task: PublishTestResults@2
      displayName: Publish test results
      condition: succeededOrFailed()
      inputs:
        testRunner: VSTest
        testResultsFiles: 'TestResult.xml'
        failTaskOnFailedTests: true
        testRunTitle: 'Unit Tests'

    # Publish the code coverage result (summary and web site)
    # The summary allows to view the coverage percentage in the summary tab
    # The web site allows to view which lines are covered directly in Azure Pipeline
    - task: PublishCodeCoverageResults@1
      displayName: 'Publish code coverage'
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: 'coverage.cobertura.xml'
        pathToSources: '$(Build.SourcesDirectory)/K2Bridge/'
        failIfCoverageEmpty: true

  - job: push_artifacts
    displayName: Push Artifacts to ACR
    dependsOn: build_and_unittest
    steps:

    - task: HelmInstaller@1
      displayName: Helm installer
      inputs:
        helmVersionToInstall: $(HELM_VERSION)

    - task: AzureCLI@1
      displayName: Login to ACR
      inputs:
        azureSubscription: $(ACR_PUSH_SERVICE_CONNECTION)
        scriptLocation: inlineScript
        inlineScript: |
          set -eux  # fail on error

          az configure --defaults acr="$ACR_NAME"
          az acr login

    - bash: |
        set -eux  # fail on error

        # Build runtime Docker image
        # Reuses the cached build stage from the previous docker build task
        docker build --build-arg VersionPrefix="$SEMANTIC_VERSION" \
          -t "$ACR_NAME.azurecr.io/k2bridge:$SEMANTIC_VERSION" \
          .

          # Build end-to-end test image
          docker build --target end2endtest \
            --build-arg VersionPrefix="$SEMANTIC_VERSION" \
            -t "$ACR_NAME.azurecr.io/k2bridge-test:$SEMANTIC_VERSION" \
          .

      displayName: Build Docker Images


    - task: AzureCLI@1
      displayName: Push Image
      inputs:
        azureSubscription: $(ACR_PUSH_SERVICE_CONNECTION)
        scriptLocation: inlineScript
        inlineScript: |
          set -eux  # fail on error

          # Push Docker image
          docker push "$ACR_NAME.azurecr.io/k2bridge:$SEMANTIC_VERSION"
          docker push "$ACR_NAME.azurecr.io/k2bridge-test:$SEMANTIC_VERSION"

    - task: AzureCLI@1
      displayName: Push Helm Charts to ACR
      inputs:
        azureSubscription: $(ACR_PUSH_SERVICE_CONNECTION)
        scriptLocation: inlineScript
        inlineScript: |
          # Push Helm chart
          helm repo add elastic https://helm.elastic.co
          helm repo update
          helm dependency update charts/k2bridge
          empty_dir="$(Build.StagingDirectory)/charts_out"
          helm package --version "$SEMANTIC_VERSION" charts/k2bridge -d $empty_dir
          az acr helm push --force "$(ls $empty_dir/*)"

- stage: Terraform
  dependsOn: []
  jobs:
  - job: Terraform
    displayName: Prepare Terraform
    steps:

    - bash: |
        set -eu
        az login --service-principal --username $(AKS_SP_CLIENT_ID) --password "$password" --tenant $(TENANT_ID)
        oid=$(az ad sp show --id  $(AKS_SP_CLIENT_ID) --query objectId -o tsv)
        echo "##vso[task.setvariable variable=AKS_SP_OBJECT_ID]$oid"
      displayName: Get AKS SP object ID
      env:
        password: $(AKS_SP_CLIENT_SECRET)

    - template: infrastructure/terraform-tasks-template.yml
      parameters:
        TerraformArguments: >-
          -var resource_group=$(RESOURCE_GROUP)
          -var vnet_name=$(VNET_NAME)
          -var aks_name=$(AKS_NAME)
          -var aks_version=$(AKS_VERSION)
          -var aks_sp_client_id=$(AKS_SP_CLIENT_ID)
          -var aks_sp_object_id=$(AKS_SP_OBJECT_ID)
          -var kusto_name=$(KUSTO_NAME)
          -var kusto_admin_sp_object_id=$(AKS_SP_OBJECT_ID)
        # For additional security, pass secret through environment instead of command line.
        # Terraform recognizes TF_VAR prefixed environment variables.
        TerraformEnvVariables:
          TF_VAR_aks_sp_client_secret: $(AKS_SP_CLIENT_SECRET)

- template: integration-tests-template.yml
  parameters:
    name: integration6
    suffix: 6
    displayName: Integr. Tests (ES6)
    elasticsearchVersion: 6.8.5

- template: integration-tests-template.yml
  parameters:
    name: integration7
    suffix: 7
    displayName: Integr. Tests (ES7)
    elasticsearchVersion: 7.5.2

- stage: Cleanup
  dependsOn:
  - integration6
  - integration7
  jobs:

  - job: Cleanup
    # Do not delete AKS namespace:
    # - if pipeline was canceled or failed before a Kubernetes namespace was generated
    # - if deploying on master branch
    # - if namespace was manually set with RUN_SET_NAMESPACE
    condition: and(always(), not(variables['RUN_SET_NAMESPACE']))
    steps:

    - template: infrastructure/setup-k8s-clients-template.yml

    - task: AzureCLI@1
      displayName: Delete AKS namespace and Kusto database
      condition: and(variables['KUBERNETES_NAMESPACE'], not(eq(variables['KUBERNETES_NAMESPACE'], 'master')))
      inputs:
        azureSubscription: $(ACR_PULL_SERVICE_CONNECTION)
        scriptLocation: inlineScript
        inlineScript: |
          set -eux  # fail on error
          kubectl delete namespace "$KUBERNETES_NAMESPACE"
          az kusto database delete -g "$(RESOURCE_GROUP)" --cluster-name "$(KUSTO_NAME)" -n "$(KUSTO_DB)" -y

- stage: release
  displayName: Release Artifacts
  dependsOn:
  - integration6
  - integration7
  jobs:

  - job: Promote
    displayName: Promote Latest Image
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), variables['RUN_FLAG_PROMOTE']))
    steps:

    - task: AzureCLI@1
      displayName: Tag Docker image as latest
      inputs:
        azureSubscription: $(ACR_PUSH_SERVICE_CONNECTION)
        scriptLocation: inlineScript
        inlineScript: |
          set -eux  # fail on error
          az configure --defaults acr="$ACR_NAME"
          az acr login
          docker pull "$ACR_NAME.azurecr.io/k2bridge:$SEMANTIC_VERSION"
          docker tag \
            "$ACR_NAME.azurecr.io/k2bridge:$SEMANTIC_VERSION" \
            "$ACR_NAME.azurecr.io/k2bridge:latest"
          docker push "$ACR_NAME.azurecr.io/k2bridge:latest"

          - task: AzureCLI@1
          displayName: Tag Docker image as latest for MCR
          inputs:
            azureSubscription: $(ACR_PUSH_SERVICE_CONNECTION)
            scriptLocation: inlineScript
            inlineScript: |
              set -eux  # fail on error
              az configure --defaults acr="$ACR_MCR_NAME"
              az acr login
              docker pull "$ACR_NAME.azurecr.io/k2bridge:$SEMANTIC_VERSION"
              docker tag \
                "$ACR_NAME.azurecr.io/k2bridge:$SEMANTIC_VERSION" \
                "$ACR_MCR_NAME.azurecr.io/public/azuredataexplorer/k2bridge:latest"
              docker push "$ACR_MCR_NAME.azurecr.io/public/azuredataexplorer/k2bridge:latest"
              docker tag \
                "$ACR_NAME.azurecr.io/k2bridge:$SEMANTIC_VERSION" \
                "$ACR_MCR_NAME.azurecr.io/k2bridge:$SEMANTIC_VERSION"
              docker push "$ACR_MCR_NAME.azurecr.io/k2bridge:$SEMANTIC_VERSION"
